{"version":3,"sources":["../src/chargePoint.js"],"names":["debug","ChargePoint","options","connectors","centralSystemUrl","reconnectTimer","reconnectInterval","self","resolve","reject","ws","perMessageDeflate","protocolVersion","on","res","headers","Error","connection","nextReconnectAttempt","removeAllListeners","onRequest","command","clearInterval","setTimeout","connect","send","promises","getConnectors","map","connector","status","timestamp","Date","toISOString","statusCommand","StatusNotification","all"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;AAEA;;;;AAKA,IAAMA,QAAQ,8CAAd;;IAEqBC,W;AACnB;;;;;;;;AAQA,uBAAaC,OAAb,EAAsB;AAAA;;AACpBA,YAAQC,UAAR,GAAqBD,QAAQC,UAAR,IAAsB,EAA3C;;AAEA,SAAKD,OAAL,GAAeA,OAAf;AACD;;;;8BAEU;AAAA;;AACTF,gCAAwB,KAAKE,OAAL,CAAaE,gBAArC;;AAEA,UAAIC,uBAAJ;AACA,UAAMC,oBAAoB,KAAKJ,OAAL,CAAaI,iBAAb,IAAkC,IAAI,EAAJ,GAAS,IAArE,CAJS,CAIkE;AAC3E,UAAMC,OAAO,IAAb;;AAEA,aAAO,sBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,KAAK,iBAAc,MAAKR,OAAL,CAAaE,gBAA3B,EAA6C,8BAA7C,EAAkE;AAC3EO,6BAAmB,KADwD;AAE3EC,2BAAiB;AAF0D,SAAlE,CAAX;;AAKAF,WAAGG,EAAH,CAAM,SAAN,EAAiB,UAACC,GAAD,EAAS;AACxB,cAAI,CAACA,IAAIC,OAAJ,CAAY,wBAAZ,CAAL,EAA4C;AAC1C,mBAAON,OAAO,IAAIO,KAAJ,oEAAP,CAAP;AACD;AACF,SAJD;;AAMAN,WAAGG,EAAH,CAAM,OAAN,EAAe,YAAM;AACnBb;AACA,gBAAKiB,UAAL,GAAkB,IAAlB;AACAC;AACD,SAJD;AAKAR,WAAGG,EAAH,CAAM,MAAN,EAAc,YAAM;AAClBH,aAAGS,kBAAH,CAAsB,OAAtB;;AAEA,gBAAKF,UAAL,GAAkB,2BAAeP,EAAf,CAAlB;AACA,gBAAKO,UAAL,CAAgBG,SAAhB,GAA4B,UAACC,OAAD;AAAA,mBAAa,MAAKD,SAAL,CAAeC,OAAf,CAAb;AAAA,WAA5B;;AAEAb,kBAAQ,MAAKS,UAAb;AACD,SAPD;;AASAP,WAAGG,EAAH,CAAM,OAAN,EAAeJ,MAAf;AACD,OA3BM,CAAP;;AA6BA,eAASS,oBAAT,GAAiC;AAAA;;AAC/B,YAAIb,cAAJ,EAAoB;AAClBiB,wBAAcjB,cAAd;AACAA,2BAAiB,IAAjB;AACD;;AAEDA,yBAAiBkB,oFAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAElBhB,KAAKiB,OAAL,EAFkB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAX,IAKdlB,iBALc,CAAjB;AAMD;AACF;;;yBAEKe,O,EAAS;AACb,UAAI,CAAC,KAAKJ,UAAV,EAAsB;AACpB,eAAO,KAAP;AACD;AACD,aAAO,KAAKA,UAAL,CAAgBQ,IAAhB,CAAqBJ,OAArB,CAAP;AACD;;;8BAEUA,O,EAAS,CACnB;;;oCAEgB;AACf,aAAO,KAAKnB,OAAL,CAAaC,UAApB;AACD;;;;;;;;;;;;AAGOuB,wB,GAAW,KAAKC,aAAL,GAAqBC,GAArB;AAAA,uGAAyB,kBAAOC,SAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAClCC,kCADkC;AAEtCC,yCAAW,IAAIC,IAAJ,GAAWC,WAAX;AAF2B,+BAGnCJ,SAHmC;AAKlCK,yCALkC,GAKlB,IAAI,mBAASC,kBAAb,CAAgCL,MAAhC,CALkB;AAAA;AAAA,mCAOlC,OAAKL,IAAL,CAAUS,aAAV,CAPkC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAzB;;AAAA;AAAA;AAAA;AAAA,oB;;uBAUJ,kBAAQE,GAAR,CAAYV,QAAZ,C;;;;;;;;;;;;;;;;;;;;;;;kBA3FIzB,W","file":"chargePoint.js","sourcesContent":["import WebSocket from 'ws';\r\nimport debugFn from 'debug';\r\nimport Commands from './commands';\r\nimport { Connection } from './connection';\r\n\r\nimport {\r\n  OCPP_PROTOCOL_1_6,\r\n  DEBUG_LIBNAME\r\n} from './constants';\r\n\r\nconst debug = debugFn(DEBUG_LIBNAME);\r\n\r\nexport default class ChargePoint {\r\n  /**\r\n   * Create OCPP client\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {String} options.centralSystemUrl The url where to connect\r\n   * @param {String} options.reconnectInterval The number of milliseconds to delay before attempting to reconnect (default: 5 minutes)\r\n   * @param {String} options.connectors Array of virtual connectors\r\n   */\r\n  constructor (options) {\r\n    options.connectors = options.connectors || [];\r\n\r\n    this.options = options;\r\n  }\r\n\r\n  connect () {\r\n    debug(`Try connect to ${this.options.centralSystemUrl}`);\r\n\r\n    let reconnectTimer;\r\n    const reconnectInterval = this.options.reconnectInterval || 5 * 60 * 1000; // 5 minutes\r\n    const self = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const ws = new WebSocket(this.options.centralSystemUrl, [OCPP_PROTOCOL_1_6], {\r\n        perMessageDeflate: false,\r\n        protocolVersion: 13\r\n      });\r\n\r\n      ws.on('upgrade', (res) => {\r\n        if (!res.headers['sec-websocket-protocol']) {\r\n          return reject(new Error(`Server doesn't support protocol ${OCPP_PROTOCOL_1_6}`));\r\n        }\r\n      });\r\n\r\n      ws.on('close', () => {\r\n        debug(`Connection is closed`);\r\n        this.connection = null;\r\n        nextReconnectAttempt();\r\n      });\r\n      ws.on('open', () => {\r\n        ws.removeAllListeners('error');\r\n\r\n        this.connection = new Connection(ws);\r\n        this.connection.onRequest = (command) => this.onRequest(command);\r\n\r\n        resolve(this.connection);\r\n      });\r\n\r\n      ws.on('error', reject);\r\n    });\r\n\r\n    function nextReconnectAttempt () {\r\n      if (reconnectTimer) {\r\n        clearInterval(reconnectTimer);\r\n        reconnectTimer = null;\r\n      }\r\n\r\n      reconnectTimer = setTimeout(async () => {\r\n        try {\r\n          await self.connect();\r\n        } catch (err) {\r\n        }\r\n      }, reconnectInterval);\r\n    }\r\n  }\r\n\r\n  send (command) {\r\n    if (!this.connection) {\r\n      return false;\r\n    }\r\n    return this.connection.send(command);\r\n  }\r\n\r\n  onRequest (command) {\r\n  }\r\n\r\n  getConnectors () {\r\n    return this.options.connectors;\r\n  }\r\n\r\n  async sendCurrentStatus() {\r\n    const promises = this.getConnectors().map(async (connector) => {\r\n      const status = {\r\n        timestamp: new Date().toISOString(),\r\n        ...connector\r\n      };\r\n      const statusCommand = new Commands.StatusNotification(status);\r\n\r\n      await this.send(statusCommand)\r\n    });\r\n\r\n    return await Promise.all(promises);\r\n  }\r\n}\r\n"]}